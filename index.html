<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>S T R E A M S C O P E</title>
    <style>
        body {
            margin: 0;
            font-family: "Gill Sans", sans-serif;
            color: #F06060;

        }

        #s1 {
            position: absolute;
            top: 10px;
            left: 130px;
            text-align: center;
            z-index: 100;
            display: block;
        }

        #s2 {
            position: absolute;
            top: 10px;
            left: 240px;
            text-align: center;
            z-index: 100;
            display: block;
        }

        #s3 {
            position: absolute;
            top: 10px;
            left: 330px;
            text-align: center;
            z-index: 100;
            display: block;
        }
    </style>
</head>

<body>

    <div id="s0"></div>
    <div id="s1">bearing</div>
    <div id="s2">colour</div>
    <div id="s3">stabilise Y</div>


    <script src="js/three.js"></script>
    <script>


        const scene = new THREE.Scene();

        scene.background = new THREE.Color('#2e2629')

        const camera = new THREE.OrthographicCamera(
            -10.1, 10.1, -10, 10, 0, 1 // left right top bottom near far
        );

        camera.position.set(0, 0, 1);

        const renderer = new THREE.WebGLRenderer();

        renderer.setSize(
            window.innerWidth,
            window.innerHeight
        );

        // add the <canvas> element to the dom
        document.body.appendChild(renderer.domElement);


        const dotsGeometry = new THREE.BufferGeometry();
        dotsGeometry.setAttribute(
            'position',
            new THREE.BufferAttribute(
                new Float32Array([-10, 0, 0]),
                3
            )
        );
        const dotsMaterial = new THREE.PointsMaterial(
            { size: 10, color: "#8CBEB2" }
        );


        var dots = [];


        const lineMaterial = new THREE.LineBasicMaterial({ color: "#243f39" });

        const points = [];

        const borders = [-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10];

        borders.map(function (i) {
            points.push(new THREE.Vector3(i, -10, 0));
            points.push(new THREE.Vector3(i, 10, 0));
        })

        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const line = new THREE.LineSegments(geometry, lineMaterial);

        scene.add(line);

        function animate() {
            requestAnimationFrame(animate);

            // update position
            dots.forEach(function (d) {
                d.geometry.position.x += d.dx(d.geometry.position.x)
                d.geometry.position.y += d.dy(d.geometry.position.y)
            })

            // remove dot from array if it's past the right edge of the screen
            dots = dots.filter(d => d.geometry.position.x < 21)


            function getSection(x) {
                return Math.ceil((x / 20) * 10)
            }

            // apply transforms 
            dots.forEach(function (d) {

                section = getSection(d.geometry.position.x)


                // check if we just crossed a boundary

                if (d.section == section) {
                    // don't do anything if we're still in the same section
                    return
                }

                d.section = section

                switch (section) {

                    case 2:
                        // change the bearing based on the change size
                        d.dy = function (y) {
                            dy = d.data.change_size / 4000
                            //console.log(dy)
                            if (dy < 0) {
                                return Math.max(dy, -0.05)
                            }
                            return Math.min(dy, 0.05)
                        };
                        break;
                    case 3:
                        // change the colour based on the action type
                        d.geometry.material = new THREE.PointsMaterial(
                            { size: 10, color: stringToColour(d.data.action) }
                        );
                        break;

                    case 4:
                        // stabilise the bearing
                        d.dy = y => 0;
                        break

                }

            })

            renderer.render(scene, camera);
        }
        animate();

        // wikipedia edits

        var stringToColour = function (str) {
            // https://stackoverflow.com/questions/3426404/create-a-hexadecimal-colour-based-on-a-string-with-javascript
            var hash = 0;
            for (var i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            var colour = '#';
            for (var i = 0; i < 3; i++) {
                var value = (hash >> (i * 8)) & 0xFF;
                colour += ('00' + value.toString(16)).substr(-2);
            }
            return colour;
        }


        url = "ws://wikimon.hatnote.com:9000"
        webSocket = new WebSocket(url)
        webSocket.onmessage = (event) => {
            data = JSON.parse(event.data);
            console.log(data)

            newDot = {
                data: data,
                section: 0,
                geometry: new THREE.Points(dotsGeometry, dotsMaterial),
                dy: y => 0,
                dx: x => 0.03 // 1 / (x + 6)
            }

            dots.push(newDot)
            scene.add(dots.at(-1).geometry);
        }


    </script>
</body>

</html>